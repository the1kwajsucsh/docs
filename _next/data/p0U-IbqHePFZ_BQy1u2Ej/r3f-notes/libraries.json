{"pageProps":{"docs":[{"slug":["r3f-notes","introduction"],"url":"/r3f-notes/introduction","editURL":"https://github.com/the1kwajsucsh/docs/tree/main/docs/r3f-notes/introduction.mdx","title":"Introduction","description":"Notes and Techniques in R3F","nav":0,"content":"\n### COPY OF ZUSTAND DOCS FOR NOW... Need to start documenting and overwriting this stuff!\n\nA small, fast and scalable bearbones state-management solution. Has a comfy api based on hooks, isn't\nboilerplatey or opinionated, but still just enough to be explicit and flux-like.\n\nDon't disregard it because it's cute. It has quite the claws, lots of time was spent to deal with common pitfalls, like the dreaded [zombie child problem](https://react-redux.js.org/api/hooks#stale-props-and-zombie-children), [react concurrency](https://github.com/bvaughn/rfcs/blob/useMutableSource/text/0000-use-mutable-source.md), and [context loss](https://github.com/facebook/react/issues/13332) between mixed renderers. It may be the one state-manager in the React space that gets all of these right.\n\nYou can try a live demo [here](https://codesandbox.io/s/dazzling-moon-itop4).\n\n```bash\nnpm install zustand\n```\n\n### First create a store\n\nYour store is a hook! You can put anything in it: primitives, objects, functions. The `set` function _merges_ state.\n\n```jsx\nimport create from 'zustand'\n\nconst useStore = create((set) => ({\n  bears: 0,\n  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n  removeAllBears: () => set({ bears: 0 }),\n}))\n```\n\n### Then bind your components, and that's it!\n\nUse the hook anywhere, no providers needed. Select your state and the component will re-render on changes.\n\n```jsx\nfunction BearCounter() {\n  const bears = useStore((state) => state.bears)\n  return <h1>{bears} around here ...</h1>\n}\n\nfunction Controls() {\n  const increasePopulation = useStore((state) => state.increasePopulation)\n  return <button onClick={increasePopulation}>one up</button>\n}\n```\n\n#### Why zustand over react-redux?\n\n- Simple and un-opinionated\n- Makes hooks the primary means of consuming state\n- Doesn't wrap your app in context providers\n- [Can inform components transiently (without causing render)](recipes#transient-updates-for-often-occurring-state-changes)\n\n---\n"},{"slug":["r3f-notes","recipes"],"url":"/r3f-notes/recipes","editURL":"https://github.com/the1kwajsucsh/docs/tree/main/docs/r3f-notes/recipes.mdx","title":"Recipes","description":"How to do all you need with Zustand","nav":1,"content":"\n## Fetching everything\n\nYou can, but bear in mind that it will cause the component to update on every state change!\n\n```jsx\nconst state = useStore()\n```\n\n## Selecting multiple state slices\n\nIt detects changes with strict-equality (old === new) by default, this is efficient for atomic state picks.\n\n```jsx\nconst nuts = useStore((state) => state.nuts)\nconst honey = useStore((state) => state.honey)\n```\n\nFor more control over re-rendering, you may provide an alternative equality function on the second argument.\n\n```jsx\nconst treats = useStore(\n  (state) => state.treats,\n  (oldTreats, newTreats) => compare(oldTreats, newTreats)\n)\n```\n\nFor instance, if you want to construct a single object with multiple state-picks inside, similar to redux's mapStateToProps, you can tell zustand that you want the object to be diffed shallowly by passing the `shallow` equality function.\n\n```jsx\nimport shallow from 'zustand/shallow'\n\n// Object pick, re-renders the component when either state.nuts or state.honey change\nconst { nuts, honey } = useStore((state) => ({ nuts: state.nuts, honey: state.honey }), shallow)\n\n// Array pick, re-renders the component when either state.nuts or state.honey change\nconst [nuts, honey] = useStore((state) => [state.nuts, state.honey], shallow)\n\n// Mapped picks, re-renders the component when state.treats changes in order, count or keys\nconst treats = useStore((state) => Object.keys(state.treats), shallow)\n```\n\n## Fetching from multiple stores\n\nSince you can create as many stores as you like, forwarding results to succeeding selectors is as natural as it gets.\n\n```jsx\nconst currentBear = useCredentialsStore((state) => state.currentBear)\nconst bear = useBearStore((state) => state.bears[currentBear])\n```\n\n## Memoizing selectors\n\nIt is generally recommended to memoize selectors with useCallback. This will prevent unnecessary computations each render. It also allows React to optimize performance in concurrent mode.\n\n```jsx\nconst fruit = useStore(useCallback((state) => state.fruits[id], [id]))\n```\n\nIf a selector doesn't depend on scope, you can define it outside the render function to obtain a fixed reference without useCallback.\n\n```jsx\nconst selector = state => state.berries\n\nfunction Component() {\n  const berries = useStore(selector)\n```\n\n## Overwriting state\n\nThe `set` function has a second argument, `false` by default. Instead of merging, it will replace the state model. Be careful not to wipe out parts you rely on, like actions.\n\n```jsx\nimport omit from 'lodash-es/omit'\n\nconst useStore = create((set) => ({\n  salmon: 1,\n  tuna: 2,\n  deleteEverything: () => set({}, true), // clears the entire store, actions included\n  deleteTuna: () => set((state) => omit(state, ['tuna']), true),\n}))\n```\n\n## Async actions\n\nJust call `set` when you're ready, zustand doesn't care if your actions are async or not.\n\n```jsx\nconst useStore = create((set) => ({\n  fishies: {},\n  fetch: async (pond) => {\n    const response = await fetch(pond)\n    set({ fishies: await response.json() })\n  },\n}))\n```\n\n## Read from state in actions\n\n`set` allows fn-updates `set(state => result)`, but you still have access to state outside of it through `get`.\n\n```jsx\nconst useStore = create((set, get) => ({\n  sound: \"grunt\",\n  action: () => {\n    const sound = get().sound\n    // ...\n  }\n})\n```\n\n## Reading/writing state and reacting to changes outside of components\n\nSometimes you need to access state in a non-reactive way, or act upon the store. For these cases the resulting hook has utility functions attached to its prototype.\n\n```jsx\nconst useStore = create(() => ({ paw: true, snout: true, fur: true }))\n\n// Getting non-reactive fresh state\nconst paw = useStore.getState().paw\n// Listening to all changes, fires on every change\nconst unsub1 = useStore.subscribe(console.log)\n// Listening to selected changes, in this case when \"paw\" changes\nconst unsub2 = useStore.subscribe(console.log, state => state.paw)\n// Subscribe also supports an optional equality function\nconst unsub3 = useStore.subscribe(console.log, state => [state.paw, state.fur], shallow)\n// Subscribe also exposes the previous value\nconst unsub4 = useStore.subscribe((paw, previousPaw) => console.log(paw, previousPaw), state => state.paw)\n// Updating state, will trigger listeners\nuseStore.setState({ paw: false })\n// Unsubscribe listeners\nunsub1()\nunsub2()\nunsub3()\nunsub4()\n// Destroying the store (removing all listeners)\nuseStore.destroy()\n\n// You can of course use the hook as you always would\nfunction Component() {\n  const paw = useStore(state => state.paw)\n```\n\n## Using zustand without React\n\nZustands core can be imported and used without the React dependency. The only difference is that the create function does not return a hook, but the api utilities.\n\n```jsx\nimport create from 'zustand/vanilla'\n\nconst store = create(() => ({ ... }))\nconst { getState, setState, subscribe, destroy } = store\n```\n\nYou can even consume an existing vanilla store with React:\n\n```jsx\nimport create from 'zustand'\nimport vanillaStore from './vanillaStore'\n\nconst useStore = create(vanillaStore)\n```\n\n## Transient updates (for often occurring state-changes)\n\nThe subscribe function allows components to bind to a state-portion without forcing re-render on changes. Best combine it with useEffect for automatic unsubscribe on unmount. This can make a [drastic](https://codesandbox.io/s/peaceful-johnson-txtws) performance impact when you are allowed to mutate the view directly.\n\n```jsx\nconst useStore = create(set => ({ scratches: 0, ... }))\n\nfunction Component() {\n  // Fetch initial state\n  const scratchRef = useRef(useStore.getState().scratches)\n  // Connect to the store on mount, disconnect on unmount, catch state-changes in a reference\n  useEffect(() => useStore.subscribe(\n    scratches => (scratchRef.current = scratches),\n    state => state.scratches\n  ), [])\n```\n\n## Sick of reducers and changing nested state? Use Immer!\n\nReducing nested structures is tiresome. Have you tried [immer](https://github.com/mweststrate/immer)?\n\n```jsx\nimport produce from 'immer'\n\nconst useStore = create((set) => ({\n  lush: { forest: { contains: { a: 'bear' } } },\n  set: (fn) => set(produce(fn)),\n}))\n\nconst set = useStore((state) => state.set)\nset((state) => {\n  state.lush.forest.contains = null\n})\n```\n\n## Middleware\n\nYou can functionally compose your store any way you like.\n\n```jsx\n// Log every time state is changed\nconst log = (config) => (set, get, api) =>\n  config(\n    (args) => {\n      console.log('  applying', args)\n      set(args)\n      console.log('  new state', get())\n    },\n    get,\n    api\n  )\n\n// Turn the set method into an immer proxy\nconst immer = (config) => (set, get, api) => config((fn) => set(produce(fn)), get, api)\n\nconst useStore = create(\n  log(\n    immer((set) => ({\n      bees: false,\n      setBees: (input) => set((state) => void (state.bees = input)),\n    }))\n  )\n)\n```\n\n<details>\n<summary>How to pipe middlewares</summary>\n\n```js\nimport create from 'zustand'\nimport produce from 'immer'\nimport pipe from 'ramda/es/pipe'\n\n/* log and immer functions from previous example */\n/* you can pipe as many middlewares as you want */\nconst createStore = pipe(log, immer, create)\n\nconst useStore = createStore((set) => ({\n  bears: 1,\n  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n}))\n\nexport default useStore\n```\n\nFor a TS example see the following [discussion](https://github.com/pmndrs/zustand/discussions/224#discussioncomment-118208)\n\n</details>\n\n<details>\n<summary>How to type immer middleware in TypeScript</summary>\n\n```ts\nimport { State, StateCreator } from 'zustand'\nimport produce, { Draft } from 'immer'\n\n// Immer V8 or lower\nconst immer =\n  <T extends State>(\n    config: StateCreator<T, (fn: (draft: Draft<T>) => void) => void>\n  ): StateCreator<T> =>\n  (set, get, api) =>\n    config((fn) => set(produce(fn) as (state: T) => T), get, api)\n\n// Immer V9\nconst immer =\n  <T extends State>(\n    config: StateCreator<T, (fn: (draft: Draft<T>) => void) => void>\n  ): StateCreator<T> =>\n  (set, get, api) =>\n    config((fn) => set(produce<T>(fn)), get, api)\n```\n\n</details>\n\n## Persist middleware\n\nYou can persist your store's data using any kind of storage.\n\n```jsx\nimport create from 'zustand'\nimport { persist } from 'zustand/middleware'\n\nexport const useStore = create(\n  persist(\n    (set, get) => ({\n      fishes: 0,\n      addAFish: () => set({ fish: get().fish + 1 }),\n    }),\n    {\n      name: 'food-storage', // unique name\n      getStorage: () => sessionStorage, // (optional) by default the 'localStorage' is used\n    }\n  )\n)\n```\n\n## Can't live without redux-like reducers and action types?\n\n```jsx\nconst types = { increase: 'INCREASE', decrease: 'DECREASE' }\n\nconst reducer = (state, { type, by = 1 }) => {\n  switch (type) {\n    case types.increase:\n      return { grumpiness: state.grumpiness + by }\n    case types.decrease:\n      return { grumpiness: state.grumpiness - by }\n  }\n}\n\nconst useStore = create((set) => ({\n  grumpiness: 0,\n  dispatch: (args) => set((state) => reducer(state, args)),\n}))\n\nconst dispatch = useStore((state) => state.dispatch)\ndispatch({ type: types.increase, by: 2 })\n```\n\nOr, just use our redux-middleware. It wires up your main-reducer, sets initial state, and adds a dispatch function to the state itself and the vanilla api. Try [this](https://codesandbox.io/s/amazing-kepler-swxol) example.\n\n```jsx\nimport { redux } from 'zustand/middleware'\n\nconst useStore = create(redux(reducer, initialState))\n```\n\n## Calling actions outside a React event handler\n\nBecause React handles `setState` synchronously if it's called outside an event handler. Updating the state outside an event handler will force react to update the components synchronously, therefore adding the risk of encountering the zombie-child effect.\nIn order to fix this, the action needs to be wrapped in `unstable_batchedUpdates`\n\n```jsx\nimport { unstable_batchedUpdates } from 'react-dom' // or 'react-native'\n\nconst useStore = create((set) => ({\n  fishes: 0,\n  increaseFishes: () => set((prev) => ({ fishes: prev.fishes + 1 })),\n}))\n\nconst nonReactCallback = () => {\n  unstable_batchedUpdates(() => {\n    useStore.getState().increaseFishes()\n  })\n}\n```\n\nMore details: https://github.com/pmndrs/zustand/issues/302\n\n## Redux devtools\n\n```jsx\nimport { devtools } from 'zustand/middleware'\n\n// Usage with a plain action store, it will log actions as \"setState\"\nconst useStore = create(devtools(store))\n// Usage with a redux store, it will log full action types\nconst useStore = create(devtools(redux(reducer, initialState)))\n```\n\ndevtools takes the store function as its first argument, optionally you can name the store with a second argument: `devtools(store, \"MyStore\")`, which will be prefixed to your actions.\ndevtools will only log actions from each separated store unlike in a typical _combined reducers_ redux store. See an approach to combining stores https://github.com/pmndrs/zustand/issues/163\n\n## TypeScript\n\n```tsx\ntype State = {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useStore = create<State>((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n}))\n```\n\nYou can also use an `interface`:\n\n```tsx\nimport { State } from 'zustand'\n\ninterface BearState extends State {\n  bears: number\n  increase: (by: number) => void\n}\n```\n\nOr, use `combine` and let tsc infer types.\n\n```tsx\nimport { combine } from 'zustand/middleware'\n\nconst useStore = create(\n  combine({ bears: 0 }, (set) => ({\n    increase: (by: number) => set((state) => ({ bears: state.bears + by })),\n  }))\n)\n```\n"},{"slug":["r3f-notes","testing"],"url":"/r3f-notes/testing","editURL":"https://github.com/the1kwajsucsh/docs/tree/main/docs/r3f-notes/testing.mdx","title":"Testing","description":"How to test your new store","nav":2,"content":"\n## Resetting state between tests\n\nWhen running tests, the stores are not automatically reset before each test run.\n\nThus, there can be cases where the state of one test can affect another. To make sure all tests run with a pristine store state, you can mock `zustand` during testing and replace it with the following code:\n\n```jsx\nimport actualCreate from 'zustand'\nimport { act } from 'react-dom/test-utils'\n\n// a variable to hold reset functions for all stores declared in the app\nconst storeResetFns = new Set()\n\n// when creating a store, we get its initial state, create a reset function and add it in the set\nconst create = (createState) => {\n  const store = actualCreate(createState)\n  const initialState = store.getState()\n  storeResetFns.add(() => store.setState(initialState, true))\n  return store\n}\n\n// Reset all stores after each test run\nafterEach(() => {\n  act(() => storeResetFns.forEach((resetFn) => resetFn()))\n})\n\nexport default create\n```\n\nThe way you can mock a dependency depends on your test runner.\n\nIn [jest](https://jestjs.io/), you can create a `__mocks__/zustand.js` and place the code there. If your app is using `zustand/vanilla` instead of `zustand`, then you'll have to place the above code in `__mocks__/zustand/vanilla.js`\n"},{"slug":["r3f-notes","libraries"],"url":"/r3f-notes/libraries","editURL":"https://github.com/the1kwajsucsh/docs/tree/main/docs/r3f-notes/libraries.mdx","title":"3rd Party Libraries","description":"","nav":3,"content":"\nZustand provides bear necessities for state management which is great for most projects; however, some users wish to extend the library's feature set. This can be done using 3rd-party libraries created by the community.\n\n> Disclaimer: These libraries may have bugs, limited maintenance, or other limitations and are not officially recommended by pmndrs or the zustand maintainers. This list is to provide a good starting point for someone looking to extend zustand's feature set.\n\n- [zustand-persist](https://github.com/roadmanfong/zustand-persist) - Persist and rehydrate state\n- [simple-zustand-devtools](https://github.com/beerose/simple-zustand-devtools) - Inspect your zustand store in React DevTools üêª‚öõÔ∏è\n- [zustand-store-addons](https://github.com/Diablow/zustand-store-addons) - React state management addons for zustand.\n- [zustand-yjs](https://github.com/tandem-pt/zustand-yjs) - Zustand stores for Yjs structures.\n- [zustand-forms](https://github.com/Conduct/zustand-forms) - fast typesafe form states as zustand stores\n- [zusteller](https://github.com/timkindberg/zusteller) - Your global state savior. \"Just hooks\" + zustand.\n- [geschichte](https://github.com/BowlingX/geschichte) - zustand and immer based hook to manage query parameters\n- [zoov](https://github.com/InfiniteXyy/zoov) - Use üêª Zustand with Module-like api\n- [mobz](https://github.com/2A5F/Mobz) - zustand style mobx api\n- [zustand-saga](https://github.com/Nowsta/zustand-saga) - Zustand middleware for redux-saga (minus redux)\n- [zundo](https://github.com/charkour/zundo) - üçú enable time-travel in your apps. undo/redo middleware for zustand\n- [zustand-middleware-computed-state](https://github.com/cmlarsen/zustand-middleware-computed-state) - This is a dead simple middleware for adding computed state to state management library Zustand.\n- [shared-zustand](https://github.com/Tom-Julux/shared-zustand) - cross-tab state sharing for zustand\n"}],"toc":[],"title":"3rd Party Libraries","description":"","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Zustand provides bear necessities for state management which is great for most projects; however, some users wish to extend the library's feature set. This can be done using 3rd-party libraries created by the community.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Disclaimer: These libraries may have bugs, limited maintenance, or other limitations and are not officially recommended by pmndrs or the zustand maintainers. This list is to provide a good starting point for someone looking to extend zustand's feature set.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/roadmanfong/zustand-persist\",\n          children: \"zustand-persist\"\n        }), \" - Persist and rehydrate state\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/beerose/simple-zustand-devtools\",\n          children: \"simple-zustand-devtools\"\n        }), \" - Inspect your zustand store in React DevTools üêª‚öõÔ∏è\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/Diablow/zustand-store-addons\",\n          children: \"zustand-store-addons\"\n        }), \" - React state management addons for zustand.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/tandem-pt/zustand-yjs\",\n          children: \"zustand-yjs\"\n        }), \" - Zustand stores for Yjs structures.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/Conduct/zustand-forms\",\n          children: \"zustand-forms\"\n        }), \" - fast typesafe form states as zustand stores\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/timkindberg/zusteller\",\n          children: \"zusteller\"\n        }), \" - Your global state savior. \\\"Just hooks\\\" + zustand.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/BowlingX/geschichte\",\n          children: \"geschichte\"\n        }), \" - zustand and immer based hook to manage query parameters\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/InfiniteXyy/zoov\",\n          children: \"zoov\"\n        }), \" - Use üêª Zustand with Module-like api\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/2A5F/Mobz\",\n          children: \"mobz\"\n        }), \" - zustand style mobx api\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/Nowsta/zustand-saga\",\n          children: \"zustand-saga\"\n        }), \" - Zustand middleware for redux-saga (minus redux)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/charkour/zundo\",\n          children: \"zundo\"\n        }), \" - üçú enable time-travel in your apps. undo/redo middleware for zustand\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/cmlarsen/zustand-middleware-computed-state\",\n          children: \"zustand-middleware-computed-state\"\n        }), \" - This is a dead simple middleware for adding computed state to state management library Zustand.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/Tom-Julux/shared-zustand\",\n          children: \"shared-zustand\"\n        }), \" - cross-tab state sharing for zustand\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}